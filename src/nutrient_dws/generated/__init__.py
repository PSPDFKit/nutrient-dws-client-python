# generated by datamodel-codegen:
#   filename:  dws-api-spec.yml
#   timestamp: 2025-08-12T04:34:51+00:00

from __future__ import annotations

from typing import Any, Literal, Optional, TypedDict, Union

from typing_extensions import NotRequired

from . import Annotation as Annotation_1
from . import InstantComment


class RequiredFeatures(TypedDict):
    unit_cost: NotRequired[float]
    unit_type: NotRequired[Literal["per_use", "per_output_page"]]
    units: NotRequired[int]
    cost: NotRequired[float]
    usage: NotRequired[list[str]]


class AnalyzeBuildResponse(TypedDict):
    cost: NotRequired[float]
    required_features: NotRequired[dict[str, RequiredFeatures]]


class PdfId(TypedDict):
    permanent: NotRequired[str]
    changing: NotRequired[str]


class CreateAuthTokenParameters(TypedDict):
    allowedOperations: NotRequired[
        list[
            Literal[
                "annotations_api",
                "compression_api",
                "data_extraction_api",
                "digital_signatures_api",
                "document_editor_api",
                "html_conversion_api",
                "image_conversion_api",
                "image_rendering_api",
                "email_conversion_api",
                "linearization_api",
                "ocr_api",
                "office_conversion_api",
                "pdfa_api",
                "pdf_to_office_conversion_api",
                "redaction_api",
            ]
        ]
    ]
    allowedOrigins: NotRequired[list[str]]
    expirationTime: NotRequired[int]


class CreateAuthTokenResponse(TypedDict):
    id: NotRequired[str]
    accessToken: NotRequired[str]


class File(TypedDict):
    url: str


class Pages(TypedDict):
    start: int
    end: int


class Document(TypedDict):
    file: NotRequired[Union[str, File]]
    pages: NotRequired[Union[list[int], Pages]]


class Confidence(TypedDict):
    threshold: float


class Options(TypedDict):
    confidence: NotRequired[Confidence]


class RedactData(TypedDict):
    documents: list[Document]
    criteria: str
    redaction_state: NotRequired[Literal["stage", "apply"]]
    options: NotRequired[Options]


class FileHandle1(TypedDict):
    url: str
    sha256: NotRequired[str]


FileHandle = Union[FileHandle1, str]


class PageRange(TypedDict):
    start: NotRequired[int]
    end: NotRequired[int]


class Size(TypedDict):
    width: NotRequired[float]
    height: NotRequired[float]


class Margin(TypedDict):
    left: NotRequired[float]
    top: NotRequired[float]
    right: NotRequired[float]
    bottom: NotRequired[float]


class PageLayout(TypedDict):
    orientation: NotRequired[Literal["portrait", "landscape"]]
    size: NotRequired[
        Union[
            Literal["A0", "A1", "A2", "A3", "A4", "A5", "A6", "A7", "A8", "Letter", "Legal"],
            Size,
        ]
    ]
    margin: NotRequired[Margin]


class ApplyInstantJsonAction(TypedDict):
    type: Literal["applyInstantJson"]
    file: FileHandle


class ApplyXfdfAction(TypedDict):
    type: Literal["applyXfdf"]
    file: FileHandle
    ignorePageRotation: NotRequired[bool]
    richTextEnabled: NotRequired[bool]


class FlattenAction(TypedDict):
    type: Literal["flatten"]
    annotationIds: NotRequired[list[Union[str, int]]]


OcrLanguage = Literal[
    "afrikaans",
    "albanian",
    "arabic",
    "armenian",
    "azerbaijani",
    "basque",
    "belarusian",
    "bengali",
    "bosnian",
    "bulgarian",
    "catalan",
    "chinese",
    "croatian",
    "czech",
    "danish",
    "dutch",
    "english",
    "finnish",
    "french",
    "german",
    "indonesian",
    "italian",
    "malay",
    "norwegian",
    "polish",
    "portuguese",
    "serbian",
    "slovak",
    "slovenian",
    "spanish",
    "swedish",
    "turkish",
    "welsh",
    "afr",
    "amh",
    "ara",
    "asm",
    "aze",
    "bel",
    "ben",
    "bod",
    "bos",
    "bre",
    "bul",
    "cat",
    "ceb",
    "ces",
    "chr",
    "cos",
    "cym",
    "dan",
    "deu",
    "div",
    "dzo",
    "ell",
    "eng",
    "enm",
    "epo",
    "equ",
    "est",
    "eus",
    "fao",
    "fas",
    "fil",
    "fin",
    "fra",
    "frk",
    "frm",
    "fry",
    "gla",
    "gle",
    "glg",
    "grc",
    "guj",
    "hat",
    "heb",
    "hin",
    "hrv",
    "hun",
    "hye",
    "iku",
    "ind",
    "isl",
    "ita",
    "jav",
    "jpn",
    "kan",
    "kat",
    "kaz",
    "khm",
    "kir",
    "kmr",
    "kor",
    "kur",
    "lao",
    "lat",
    "lav",
    "lit",
    "ltz",
    "mal",
    "mar",
    "mkd",
    "mlt",
    "mon",
    "mri",
    "msa",
    "mya",
    "nep",
    "nld",
    "nor",
    "oci",
    "ori",
    "osd",
    "pan",
    "pol",
    "por",
    "pus",
    "que",
    "ron",
    "rus",
    "san",
    "sin",
    "slk",
    "slv",
    "snd",
    "sp1",
    "spa",
    "sqi",
    "srp",
    "sun",
    "swa",
    "swe",
    "syr",
    "tam",
    "tat",
    "tel",
    "tgk",
    "tgl",
    "tha",
    "tir",
    "ton",
    "tur",
    "uig",
    "ukr",
    "urd",
    "uzb",
    "vie",
    "yid",
    "yor",
]


class OcrAction(TypedDict):
    type: Literal["ocr"]
    language: Union[OcrLanguage, list[OcrLanguage]]


class RotateAction(TypedDict):
    type: Literal["rotate"]
    rotateBy: Literal[90, 180, 270]


class WatermarkDimension(TypedDict):
    value: float
    unit: Literal["pt", "%"]


class BaseWatermarkAction(TypedDict):
    type: Literal["watermark"]
    width: WatermarkDimension
    height: WatermarkDimension
    top: NotRequired[WatermarkDimension]
    right: NotRequired[WatermarkDimension]
    bottom: NotRequired[WatermarkDimension]
    left: NotRequired[WatermarkDimension]
    rotation: NotRequired[float]
    opacity: NotRequired[float]


class TextWatermarkAction(BaseWatermarkAction):
    text: str
    fontFamily: NotRequired[str]
    fontSize: NotRequired[int]
    fontColor: NotRequired[str]
    fontStyle: NotRequired[list[Literal["bold", "italic"]]]


class ImageWatermarkAction(BaseWatermarkAction):
    image: FileHandle


WatermarkAction = Union[TextWatermarkAction, ImageWatermarkAction]


PageIndex = int


AnnotationBbox = list[float]


class BaseAction(TypedDict):
    subAction: NotRequired[dict[str, Any]]


class GoToAction(BaseAction):
    type: Literal["goTo"]
    pageIndex: int


class GoToRemoteAction(BaseAction):
    type: Literal["goToRemote"]
    relativePath: str
    namedDestination: NotRequired[str]


class GoToEmbeddedAction(BaseAction):
    type: Literal["goToEmbedded"]
    relativePath: str
    newWindow: NotRequired[bool]
    targetType: NotRequired[Literal["parent", "child"]]


class LaunchAction(BaseAction):
    type: Literal["launch"]
    filePath: str


class URIAction(BaseAction):
    type: Literal["uri"]
    uri: str


class AnnotationReference(TypedDict):
    fieldName: NotRequired[str]
    pdfObjectId: NotRequired[int]


class HideAction(BaseAction):
    type: Literal["hide"]
    hide: bool
    annotationReferences: list[AnnotationReference]


class JavaScriptAction(BaseAction):
    type: Literal["javascript"]
    script: str


class SubmitFormAction(BaseAction):
    type: Literal["submitForm"]
    uri: str
    flags: list[
        Literal[
            "includeExclude",
            "includeNoValueFields",
            "exportFormat",
            "getMethod",
            "submitCoordinated",
            "xfdf",
            "includeAppendSaves",
            "includeAnnotations",
            "submitPDF",
            "canonicalFormat",
            "excludeNonUserAnnotations",
            "excludeFKey",
            "embedForm",
        ]
    ]
    fields: NotRequired[list[AnnotationReference]]


class ResetFormAction(BaseAction):
    type: Literal["resetForm"]
    flags: NotRequired[Literal["includeExclude"]]
    fields: NotRequired[list[AnnotationReference]]


class NamedAction(BaseAction):
    type: Literal["named"]
    action: Literal[
        "nextPage",
        "prevPage",
        "firstPage",
        "lastPage",
        "goBack",
        "goForward",
        "goToPage",
        "find",
        "print",
        "outline",
        "search",
        "brightness",
        "zoomIn",
        "zoomOut",
        "saveAs",
        "info",
    ]


Action = Union[
    GoToAction,
    GoToRemoteAction,
    GoToEmbeddedAction,
    LaunchAction,
    URIAction,
    HideAction,
    JavaScriptAction,
    SubmitFormAction,
    ResetFormAction,
    NamedAction,
]


AnnotationOpacity = float


PdfObjectId = int


AnnotationCustomData = Optional[dict[str, Any]]


class BaseAnnotation(TypedDict):
    v: Literal[2]
    type: str
    pageIndex: PageIndex
    bbox: AnnotationBbox
    action: NotRequired[Action]
    opacity: NotRequired[AnnotationOpacity]
    pdfObjectId: NotRequired[PdfObjectId]
    id: NotRequired[str]
    flags: NotRequired[
        list[
            Literal[
                "noPrint",
                "noZoom",
                "noRotate",
                "noView",
                "hidden",
                "invisible",
                "readOnly",
                "locked",
                "toggleNoView",
                "lockedContents",
            ]
        ]
    ]
    createdAt: NotRequired[str]
    updatedAt: NotRequired[str]
    name: NotRequired[str]
    creatorName: NotRequired[str]
    customData: NotRequired[Optional[AnnotationCustomData]]


Rect = list[float]


AnnotationRotation = Literal[0, 90, 180, 270]


AnnotationNote = str


class RedactionAnnotation(BaseAnnotation):
    type: Literal["pspdfkit/markup/redaction"]
    rects: NotRequired[list[Rect]]
    outlineColor: NotRequired[str]
    fillColor: NotRequired[str]
    overlayText: NotRequired[str]
    repeatOverlayText: NotRequired[bool]
    color: NotRequired[str]
    rotation: NotRequired[AnnotationRotation]
    note: NotRequired[AnnotationNote]


SearchPreset = Literal[
    "credit-card-number",
    "date",
    "email-address",
    "international-phone-number",
    "ipv4",
    "ipv6",
    "mac-address",
    "north-american-phone-number",
    "social-security-number",
    "time",
    "url",
    "us-zip-code",
    "vin",
]


class CreateRedactionsStrategyOptionsPreset(TypedDict):
    preset: SearchPreset
    includeAnnotations: NotRequired[bool]
    start: NotRequired[int]
    limit: NotRequired[int]


class CreateRedactionsStrategyOptionsRegex(TypedDict):
    regex: str
    includeAnnotations: NotRequired[bool]
    caseSensitive: NotRequired[bool]
    start: NotRequired[int]
    limit: NotRequired[int]


class CreateRedactionsStrategyOptionsText(TypedDict):
    text: str
    includeAnnotations: NotRequired[bool]
    caseSensitive: NotRequired[bool]
    start: NotRequired[int]
    limit: NotRequired[int]


class CreateRedactionsAction1(TypedDict):
    strategy: Literal["preset"]
    strategyOptions: CreateRedactionsStrategyOptionsPreset


class CreateRedactionsAction2(TypedDict):
    strategy: Literal["regex"]
    strategyOptions: CreateRedactionsStrategyOptionsRegex


class CreateRedactionsAction3(TypedDict):
    strategy: Literal["text"]
    strategyOptions: CreateRedactionsStrategyOptionsText


class CreateRedactionsAction4(TypedDict):
    type: Literal["createRedactions"]
    content: NotRequired[RedactionAnnotation]


class CreateRedactionsAction5(CreateRedactionsAction1, CreateRedactionsAction4):
    pass


class CreateRedactionsAction6(CreateRedactionsAction2, CreateRedactionsAction4):
    pass


class CreateRedactionsAction7(CreateRedactionsAction3, CreateRedactionsAction4):
    pass


CreateRedactionsAction = Union[
    CreateRedactionsAction5, CreateRedactionsAction6, CreateRedactionsAction7
]


class ApplyRedactionsAction(TypedDict):
    type: Literal["applyRedactions"]


BuildAction = Union[
    ApplyInstantJsonAction,
    ApplyXfdfAction,
    FlattenAction,
    OcrAction,
    RotateAction,
    WatermarkAction,
    CreateRedactionsAction,
    ApplyRedactionsAction,
]


class FilePart(TypedDict):
    file: FileHandle
    password: NotRequired[str]
    pages: NotRequired[PageRange]
    layout: NotRequired[PageLayout]
    content_type: NotRequired[str]
    actions: NotRequired[list[BuildAction]]


class HTMLPart(TypedDict):
    html: FileHandle
    assets: NotRequired[list[str]]
    layout: NotRequired[PageLayout]
    actions: NotRequired[list[BuildAction]]


class NewPagePart(TypedDict):
    page: Literal["new"]
    pageCount: NotRequired[int]
    layout: NotRequired[PageLayout]
    actions: NotRequired[list[BuildAction]]


DocumentId = str


class Document1(TypedDict):
    id: Union[DocumentId, Literal["#self"]]
    layer: NotRequired[str]


class DocumentPart(TypedDict):
    document: Document1
    password: NotRequired[str]
    pages: NotRequired[PageRange]
    actions: NotRequired[list[BuildAction]]


Part = Union[FilePart, HTMLPart, NewPagePart, DocumentPart]


Title = Optional[str]


class Metadata(TypedDict):
    title: NotRequired[Optional[Title]]
    author: NotRequired[str]


class Label(TypedDict):
    pages: list[int]
    label: str


PDFUserPermission = Literal[
    "printing",
    "modification",
    "extract",
    "annotations_and_forms",
    "fill_forms",
    "extract_accessibility",
    "assemble",
    "print_high_quality",
]


class OptimizePdf(TypedDict):
    grayscaleText: NotRequired[bool]
    grayscaleGraphics: NotRequired[bool]
    grayscaleImages: NotRequired[bool]
    grayscaleFormFields: NotRequired[bool]
    grayscaleAnnotations: NotRequired[bool]
    disableImages: NotRequired[bool]
    mrcCompression: NotRequired[bool]
    imageOptimizationQuality: NotRequired[int]
    linearize: NotRequired[bool]


class BasePDFOutput(TypedDict):
    metadata: NotRequired[Metadata]
    labels: NotRequired[list[Label]]
    user_password: NotRequired[str]
    owner_password: NotRequired[str]
    user_permissions: NotRequired[list[PDFUserPermission]]
    optimize: NotRequired[OptimizePdf]


class PDFOutput(BasePDFOutput):
    type: NotRequired[Literal["pdf"]]


class PDFAOutput(BasePDFOutput):
    type: Literal["pdfa"]
    conformance: NotRequired[
        Literal["pdfa-1a", "pdfa-1b", "pdfa-2a", "pdfa-2u", "pdfa-2b", "pdfa-3a", "pdfa-3u"]
    ]
    vectorization: NotRequired[bool]
    rasterization: NotRequired[bool]


class PDFUAOutput(BasePDFOutput):
    type: Literal["pdfua"]


class ImageOutput(TypedDict):
    type: Literal["image"]
    format: NotRequired[Literal["png", "jpeg", "jpg", "webp"]]
    pages: NotRequired[PageRange]
    width: NotRequired[float]
    height: NotRequired[float]
    dpi: NotRequired[float]


class JSONContentOutput(TypedDict):
    type: Literal["json-content"]
    plainText: NotRequired[bool]
    structuredText: NotRequired[bool]
    keyValuePairs: NotRequired[bool]
    tables: NotRequired[bool]
    language: NotRequired[Union[OcrLanguage, list[OcrLanguage]]]


class OfficeOutput(TypedDict):
    type: Literal["docx", "xlsx", "pptx"]


class HTMLOutput(TypedDict):
    type: Literal["html"]
    layout: NotRequired[Literal["page", "reflow"]]


class MarkdownOutput(TypedDict):
    type: Literal["markdown"]


BuildOutput = Union[
    PDFOutput,
    PDFAOutput,
    PDFUAOutput,
    ImageOutput,
    JSONContentOutput,
    OfficeOutput,
    HTMLOutput,
    MarkdownOutput,
]


class BuildInstructions(TypedDict):
    parts: list[Part]
    actions: NotRequired[list[BuildAction]]
    output: NotRequired[BuildOutput]


class FailingPath(TypedDict):
    path: NotRequired[str]
    details: NotRequired[str]


class HostedErrorResponse(TypedDict):
    details: NotRequired[str]
    status: NotRequired[Literal[400, 402, 408, 413, 422, 500]]
    requestId: NotRequired[str]
    failingPaths: NotRequired[list[FailingPath]]


class Appearance(TypedDict):
    mode: NotRequired[Literal["signatureOnly", "signatureAndDescription", "descriptionOnly"]]
    contentType: NotRequired[str]
    showWatermark: NotRequired[bool]
    showSignDate: NotRequired[bool]
    showDateTimezone: NotRequired[bool]


class Position(TypedDict):
    pageIndex: int
    rect: list[float]


class CreateDigitalSignature(TypedDict):
    signatureType: Literal["cms", "cades"]
    flatten: NotRequired[bool]
    formFieldName: NotRequired[str]
    appearance: NotRequired[Appearance]
    position: NotRequired[Position]
    cadesLevel: NotRequired[Literal["b-lt", "b-t", "b-b"]]


BlendMode = Literal[
    "normal",
    "multiply",
    "screen",
    "overlay",
    "darken",
    "lighten",
    "colorDodge",
    "colorBurn",
    "hardLight",
    "softLight",
    "difference",
    "exclusion",
]


IsCommentThreadRoot = bool


class MarkupAnnotation(BaseAnnotation):
    type: Literal[
        "pspdfkit/markup/highlight",
        "pspdfkit/markup/squiggly",
        "pspdfkit/markup/strikeout",
        "pspdfkit/markup/underline",
    ]
    rects: list[Rect]
    blendMode: NotRequired[BlendMode]
    color: str
    note: NotRequired[AnnotationNote]
    isCommentThreadRoot: NotRequired[IsCommentThreadRoot]


class AnnotationText(TypedDict):
    format: NotRequired[Literal["xhtml", "plain"]]
    value: NotRequired[str]


FontSizeInt = int


FontStyle = list[Literal["bold", "italic"]]


FontColor = str


Font = str


HorizontalAlign = Literal["left", "center", "right"]


VerticalAlign = Literal["top", "center", "bottom"]


Point = list[float]


LineCap = Literal[
    "square",
    "circle",
    "diamond",
    "openArrow",
    "closedArrow",
    "butt",
    "reverseOpenArrow",
    "reverseClosedArrow",
    "slash",
]


BorderStyle = Literal["solid", "dashed", "beveled", "inset", "underline"]


CloudyBorderIntensity = float


CloudyBorderInset = list[float]


class Callout(TypedDict):
    start: Point
    end: Point
    innerRectInset: list[float]
    cap: NotRequired[LineCap]
    knee: NotRequired[Point]


class TextAnnotation(BaseAnnotation):
    type: Literal["pspdfkit/text"]
    text: AnnotationText
    fontSize: FontSizeInt
    fontStyle: NotRequired[FontStyle]
    fontColor: NotRequired[FontColor]
    font: NotRequired[Font]
    backgroundColor: NotRequired[str]
    horizontalAlign: HorizontalAlign
    verticalAlign: VerticalAlign
    rotation: NotRequired[AnnotationRotation]
    isFitting: NotRequired[bool]
    callout: NotRequired[Callout]
    borderStyle: NotRequired[BorderStyle]
    borderWidth: NotRequired[int]
    cloudyBorderIntensity: NotRequired[CloudyBorderIntensity]
    cloudyBorderInset: NotRequired[CloudyBorderInset]


Intensity = float


class Lines(TypedDict):
    intensities: NotRequired[list[list[Intensity]]]
    points: NotRequired[list[list[Point]]]


BackgroundColor = str


class InkAnnotation(BaseAnnotation):
    type: Literal["pspdfkit/ink"]
    lines: Lines
    lineWidth: int
    isDrawnNaturally: NotRequired[bool]
    isSignature: NotRequired[bool]
    strokeColor: NotRequired[str]
    backgroundColor: NotRequired[BackgroundColor]
    blendMode: NotRequired[BlendMode]
    note: NotRequired[AnnotationNote]


class LinkAnnotation(BaseAnnotation):
    type: Literal["pspdfkit/link"]
    borderColor: NotRequired[str]
    borderStyle: NotRequired[BorderStyle]
    borderWidth: NotRequired[int]
    note: NotRequired[AnnotationNote]


NoteIcon = Literal[
    "comment",
    "rightPointer",
    "rightArrow",
    "check",
    "circle",
    "cross",
    "insert",
    "newParagraph",
    "note",
    "paragraph",
    "help",
    "star",
    "key",
]


class NoteAnnotation(BaseAnnotation):
    text: AnnotationText
    icon: NoteIcon
    color: NotRequired[str]


MeasurementScale = TypedDict(
    "MeasurementScale",
    {
        "unitFrom": NotRequired[Literal["in", "mm", "cm", "pt"]],
        "unitTo": NotRequired[Literal["in", "mm", "cm", "pt", "ft", "m", "yd", "km", "mi"]],
        "from": NotRequired[float],
        "to": NotRequired[float],
    },
)


MeasurementPrecision = Literal["whole", "oneDp", "twoDp", "threeDp", "fourDp"]


class ShapeAnnotation(TypedDict):
    strokeDashArray: NotRequired[list[float]]
    strokeWidth: NotRequired[float]
    strokeColor: NotRequired[str]
    note: NotRequired[AnnotationNote]
    measurementScale: NotRequired[MeasurementScale]
    measurementPrecision: NotRequired[MeasurementPrecision]


FillColor = str


class EllipseAnnotation(BaseAnnotation, ShapeAnnotation):
    type: Literal["pspdfkit/shape/ellipse"]
    fillColor: NotRequired[FillColor]
    cloudyBorderIntensity: NotRequired[CloudyBorderIntensity]
    cloudyBorderInset: NotRequired[CloudyBorderInset]


class RectangleAnnotation(BaseAnnotation, ShapeAnnotation):
    type: Literal["pspdfkit/shape/rectangle"]
    fillColor: NotRequired[FillColor]
    cloudyBorderIntensity: NotRequired[CloudyBorderIntensity]
    cloudyBorderInset: NotRequired[CloudyBorderInset]


class LineCaps(TypedDict):
    start: NotRequired[LineCap]
    end: NotRequired[LineCap]


class LineAnnotation(BaseAnnotation, ShapeAnnotation):
    type: Literal["pspdfkit/shape/line"]
    startPoint: Point
    endPoint: Point
    fillColor: NotRequired[FillColor]
    lineCaps: NotRequired[LineCaps]


class PolylineAnnotation(BaseAnnotation, ShapeAnnotation):
    type: Literal["pspdfkit/shape/polyline"]
    fillColor: NotRequired[FillColor]
    points: list[Point]
    lineCaps: NotRequired[LineCaps]
    cloudyBorderIntensity: NotRequired[CloudyBorderIntensity]
    cloudyBorderInset: NotRequired[CloudyBorderInset]


class PolygonAnnotation(BaseAnnotation, ShapeAnnotation):
    type: Literal["pspdfkit/shape/polygon"]
    fillColor: NotRequired[FillColor]
    points: list[Point]
    cloudyBorderIntensity: NotRequired[CloudyBorderIntensity]


class ImageAnnotation(BaseAnnotation):
    type: Literal["pspdfkit/image"]
    description: NotRequired[str]
    fileName: NotRequired[str]
    contentType: NotRequired[Literal["image/jpeg", "image/png", "application/pdf"]]
    imageAttachmentId: NotRequired[str]
    rotation: NotRequired[AnnotationRotation]
    isSignature: NotRequired[bool]
    note: NotRequired[AnnotationNote]


class StampAnnotation(BaseAnnotation):
    type: Literal["pspdfkit/stamp"]
    stampType: Literal[
        "Accepted",
        "Approved",
        "AsIs",
        "Completed",
        "Confidential",
        "Departmental",
        "Draft",
        "Experimental",
        "Expired",
        "Final",
        "ForComment",
        "ForPublicRelease",
        "InformationOnly",
        "InitialHere",
        "NotApproved",
        "NotForPublicRelease",
        "PreliminaryResults",
        "Rejected",
        "Revised",
        "SignHere",
        "Sold",
        "TopSecret",
        "Void",
        "Witness",
        "Custom",
    ]
    title: NotRequired[str]
    subtitle: NotRequired[str]
    color: NotRequired[str]
    rotation: NotRequired[AnnotationRotation]
    note: NotRequired[AnnotationNote]


FontSizeAuto = Literal["auto"]


class WidgetAnnotation(BaseAnnotation):
    type: Literal["pspdfkit/widget"]
    formFieldName: NotRequired[str]
    borderColor: NotRequired[str]
    borderStyle: NotRequired[BorderStyle]
    borderWidth: NotRequired[int]
    font: NotRequired[Font]
    fontSize: NotRequired[Union[FontSizeInt, FontSizeAuto]]
    fontColor: NotRequired[FontColor]
    fontStyle: NotRequired[FontStyle]
    horizontalAlign: NotRequired[HorizontalAlign]
    verticalAlign: NotRequired[VerticalAlign]
    rotation: NotRequired[AnnotationRotation]
    backgroundColor: NotRequired[BackgroundColor]


class CommentMarkerAnnotation(BaseAnnotation):
    text: NotRequired[AnnotationText]
    icon: NoteIcon
    color: NotRequired[str]
    isCommentThreadRoot: NotRequired[IsCommentThreadRoot]


Annotation = Union[
    MarkupAnnotation,
    RedactionAnnotation,
    TextAnnotation,
    InkAnnotation,
    LinkAnnotation,
    NoteAnnotation,
    EllipseAnnotation,
    RectangleAnnotation,
    LineAnnotation,
    PolylineAnnotation,
    PolygonAnnotation,
    ImageAnnotation,
    StampAnnotation,
    WidgetAnnotation,
    CommentMarkerAnnotation,
]


AnnotationPlainText = str


class Attachment(TypedDict):
    binary: NotRequired[str]
    contentType: NotRequired[str]


Attachments = Optional[dict[str, Attachment]]


class BaseFormField(TypedDict):
    v: Literal[1]
    type: str
    id: NotRequired[str]
    name: str
    label: str
    annotationIds: list[str]
    pdfObjectId: NotRequired[int]
    flags: NotRequired[list[Literal["readOnly", "required", "noExport"]]]


class ButtonFormField(BaseFormField):
    type: Literal["pspdfkit/form-field/button"]
    buttonLabel: str


class FormFieldOption(TypedDict):
    label: str
    value: str


FormFieldOptions = list[FormFieldOption]


FormFieldDefaultValues = list[str]


class FormFieldAdditionalActionsEvent(TypedDict):
    onChange: NotRequired[Action]
    onCalculate: NotRequired[Action]


class ChoiceFormField(TypedDict):
    options: FormFieldOptions
    multiSelect: NotRequired[bool]
    commitOnChange: NotRequired[bool]
    defaultValues: NotRequired[FormFieldDefaultValues]
    additionalActions: NotRequired[FormFieldAdditionalActionsEvent]


class FormFieldAdditionalActionsInput(TypedDict):
    onInput: NotRequired[Action]
    onFormat: NotRequired[Action]


class AdditionalActions(FormFieldAdditionalActionsEvent, FormFieldAdditionalActionsInput):
    pass


class ListBoxFormField(BaseFormField, ChoiceFormField):
    type: NotRequired[Literal["pspdfkit/form-field/listbox"]]
    additionalActions: NotRequired[AdditionalActions]


class ComboBoxFormField(BaseFormField, ChoiceFormField):
    type: NotRequired[Literal["pspdfkit/form-field/combobox"]]
    edit: bool
    doNotSpellCheck: bool


class CheckboxFormField(BaseFormField):
    type: Literal["pspdfkit/form-field/checkbox"]
    options: FormFieldOptions
    defaultValues: FormFieldDefaultValues
    additionalActions: NotRequired[FormFieldAdditionalActionsEvent]


FormFieldDefaultValue = str


class RadioButtonFormField(BaseFormField):
    type: Literal["pspdfkit/form-field/radio"]
    options: FormFieldOptions
    defaultValue: NotRequired[FormFieldDefaultValue]
    noToggleToOff: NotRequired[bool]
    radiosInUnison: NotRequired[bool]


class TextFormField(BaseFormField):
    type: Literal["pspdfkit/form-field/text"]
    password: NotRequired[bool]
    maxLength: NotRequired[int]
    doNotSpellCheck: bool
    doNotScroll: bool
    multiLine: bool
    comb: bool
    defaultValue: FormFieldDefaultValue
    richText: NotRequired[bool]
    richTextValue: NotRequired[str]
    additionalActions: NotRequired[AdditionalActions]


class SignatureFormField(BaseFormField):
    type: NotRequired[Literal["pspdfkit/form-field/signature"]]


FormField = Union[
    ButtonFormField,
    ListBoxFormField,
    ComboBoxFormField,
    CheckboxFormField,
    RadioButtonFormField,
    TextFormField,
    SignatureFormField,
]


class FormFieldValue(TypedDict):
    name: str
    value: NotRequired[Union[Optional[str], list[str]]]
    type: Literal["pspdfkit/form-field-value"]
    v: Literal[1]
    optionIndexes: NotRequired[list[int]]
    isFitting: NotRequired[bool]


class Bookmark(TypedDict):
    name: NotRequired[str]
    type: Literal["pspdfkit/bookmark"]
    v: Literal[1]
    action: Action
    pdfBookmarkId: NotRequired[str]


IsoDateTime = str


CustomData = Optional[dict[str, Any]]


CommentContent = Union[InstantComment.V2, InstantComment.V1]


class InstantJson(TypedDict):
    format: Literal["https://pspdfkit.com/instant-json/v1"]
    annotations: NotRequired[list[Union[Annotation, Annotation_1.V1]]]
    attachments: NotRequired[Attachments]
    formFields: NotRequired[list[FormField]]
    formFieldValues: NotRequired[list[FormFieldValue]]
    bookmarks: NotRequired[list[Bookmark]]
    comments: NotRequired[list[CommentContent]]
    skippedPdfObjectIds: NotRequired[list[int]]
    pdfId: NotRequired[PdfId]


# JSON Content Types for Build Response
PlainText = str


class JsonContentsBbox(TypedDict):
    """Represents a rectangular region on the page."""

    left: float
    top: float
    width: float
    height: float


class Character(TypedDict):
    """Character in structured text."""

    bbox: JsonContentsBbox
    char: str


class Line(TypedDict):
    """Line in structured text."""

    bbox: JsonContentsBbox
    text: str


class Word(TypedDict):
    """Word in structured text."""

    bbox: JsonContentsBbox
    text: str


class Paragraph(TypedDict):
    """Paragraph in structured text."""

    bbox: JsonContentsBbox
    text: str


class StructuredText(TypedDict):
    """Structured text content."""

    characters: NotRequired[list[Character]]
    lines: NotRequired[list[Line]]
    paragraphs: NotRequired[list[Paragraph]]
    words: NotRequired[list[Word]]


class KVPKey(TypedDict):
    """Key-value pair key."""

    bbox: JsonContentsBbox
    confidence: float
    text: str


class KVPValue(TypedDict):
    """Key-value pair value."""

    bbox: JsonContentsBbox
    confidence: float
    text: str


class KeyValuePair(TypedDict):
    """Detected key-value pair."""

    confidence: float
    key: KVPKey
    value: KVPValue


class TableCell(TypedDict):
    """Table cell."""

    bbox: JsonContentsBbox
    rowIndex: int
    colIndex: int
    text: str


class TableColumn(TypedDict):
    """Table column."""

    bbox: JsonContentsBbox


class TableLine(TypedDict):
    """Table line."""

    bbox: JsonContentsBbox


class TableRow(TypedDict):
    """Table row."""

    bbox: JsonContentsBbox


class Table(TypedDict):
    """Detected table."""

    confidence: float
    bbox: JsonContentsBbox
    cells: list[TableCell]
    columns: list[TableColumn]
    lines: list[TableLine]
    rows: list[TableRow]


class PageJsonContents(TypedDict):
    """JSON content for a single page."""

    pageIndex: int
    plainText: NotRequired[PlainText]
    structuredText: NotRequired[StructuredText]
    keyValuePairs: NotRequired[list[KeyValuePair]]
    tables: NotRequired[list[Table]]


class BuildResponseJsonContents(TypedDict):
    """Build response JSON contents."""

    pages: NotRequired[list[PageJsonContents]]
